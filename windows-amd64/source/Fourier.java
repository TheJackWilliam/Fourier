/* autogenerated by Processing revision 1281 on 2022-03-23 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Fourier extends PApplet {

FourierTransform fourierTransform;
Waveform wave;
boolean run = false;

float step, unitLength, freqStep = 0.005f, freqRange = 32, unitsPerWindow = 5;

 public void setup() {
  /* size commented out by preprocessor */;
  noFill();
  stroke(255, 255, 255, 255/8);
  strokeWeight(1);
  
  //// Use this for the wave versions
  unitLength = width/2 / unitsPerWindow;
  step = freqRange*10/unitLength;
  
  //println(unitLength*unitsPerWindow);
  //println(unitLength/unitsPerWindow/step);
  //println(unitsPerWindow/unitLength*step);
  //fWave = new FourierWave(new FloatVec(width/2, height/2));
  
  //// Domain space, Amplitude, Frequency, Phase (cosine)
  //wave = new WaveForm(width*1/2, height/(16+random(-4,4)), random(1,5), random(-HALF_PI, HALF_PI));
  //wave.addFloatWave(new WaveForm(width*1/2, height/(16+random(-4,4)), random(1,freqRange), random(-HALF_PI, HALF_PI)));
  //wave.addFloatWave(new WaveForm(width*1/2, height/(16+random(-4,4)), random(1,freqRange), random(-HALF_PI, HALF_PI)));
  
  // Sqaure Wave
  wave = new Waveform(width*1/2, height/5);
  
  //// Circle
  //ArrayList<FloatVec> floatWave = new ArrayList<FloatVec>();
  //for (float i = 0; i < TWO_PI; i += 1/step) {
  //  floatWave.add(new FloatVec(height/5*cos(i)+width/4, height/5*sin(i)));
  //}
  //wave = new Waveform(floatWave, width/2);
  
  fourierTransform = new FourierTransform(wave, width/2);
  
  background(20);
  
  stroke(255);
  strokeWeight(1);
  wave.showFloatWave(0, height*1/4);  
}

 public void draw() {
  if (run) {
    // draw backgrounds
    stroke(20);
    fill(20);
    rect(width/2, 0, width, height/2);
    rect(0, height/2, width/2, height);
    rect(width/2, height/2, width, height);
    noFill();  
    
    // separate windows
    stroke(255);
    strokeWeight(1);
    line(width/2, 0, width/2, height);
    line(0, height/2, width, height/2);
    line(0, height*4/6, width*1/2, height*4/6);
    line(0, height*5/6, width*1/2, height*5/6);
    
    // draw complex plane
    stroke(255, 255/2);
    strokeWeight(1);
    line(width*3/4, 0, width*3/4, height*1/2);
    line(width*1/2, height*1/4, width, height*1/4);
    
    // draw unit lines
    stroke(255, 255/4);
    strokeWeight(1);
    for (int i = 0; i*width/2/freqRange < width/2; i++) {
      line(i*width/2/freqRange, height/2, i*width/2/freqRange, height);
    }
    
    // draw zero reference and 1 unit tick marks
    stroke(255, 255/2);
    strokeWeight(1);
    line(0, height*7/12, width*1/2, height*7/12);
    line(0, height*9/12, width*1/2, height*9/12);
    line(0, height*11/12, width*1/2, height*11/12);
    
    
    // Fourier Illustration is Complete
    //if (run) {
    //  background(20, 20, 20);
    //  fWave.addCircle(new FourierCircle(scale/step, 0, time/step));
    //  fWave.show(true, false);
    //  fWave.showPoints();
    //  fWave.update();
      
    //  time++;
    //} 
    
    // Wrap Waveform around the complex plane
    fourierTransform.compute_Y(width*3/4, height*1/4);
    
    // draw frequency line
    stroke(255, 255/2);
    strokeWeight(1);
    if (fourierTransform.freq/freqRange*width/2 < width/2) line(fourierTransform.freq/freqRange*width/2, height/2, fourierTransform.freq/freqRange*width/2, height);
    
    // draw fourierTransform Components
    fourierTransform.showComplexMag_Y(0, height*7/12);
    fourierTransform.showComplexComponents_Y(0, height*9/12);
    fourierTransform.showComplexPhase_Y(0, height*11/12);
    
    // draw inverse fourier
    fourierTransform.showFourierWave_Y();
  }
}

 public void mouseClicked() {
  run = run == false;
}
class Complex {
  public float a, b;
  Complex() {}
  Complex(float _a, float _b) {
    this.a = _a;
    this.b = _b;
  }
  public float magnitude() { 
    return sqrt(pow(this.a,2) + pow(this.b,2)); 
  }
  public float phase(/* float threshold */) {
    float offset = 0;
    if (this.a < 0 && this.b > 0) offset += PI;
    if (this.a < 0 && this.b < 0) offset -= PI;
    return atan(this.b / this.a) + offset; 
  }
  public void add(float _a, float _b) {
    this.a += _a;
    this.b += _b;
  }
  public void div(float _k) {
    this.a /= _k;
    this.b /= _k;
  }
};
class FloatVec {
  public float x, y;
  FloatVec() {
    this.x = 0;
    this.y = 0;
  }
  FloatVec(float i, float j) {
   this.set(i, j);
  }
  public void set(float i, float j) {
    this.x = i;
    this.y = j;
  }
  public void copy(FloatVec _fv) {
     this.x = _fv.x;
     this.y = _fv.y;
  }
  public void add(float _x, float _y) {
    this.x += _x;
    this.y += _y;
  }
  public void add(FloatVec _fv) {
    this.x += _fv.x;
    this.y += _fv.y;
  }
  public void sub(FloatVec _fv) {
    this.x -= _fv.x;
    this.y -= _fv.y;
  }
   public void mult(float _k) {
    this.x *= _k;
    this.y *= _k;
  }
  public void mult(FloatVec _fv) {
    this.x *= _fv.x;
    this.y *= _fv.y;
  }
  public void div(float _k) {
    if (_k != 0) {
      this.x /= _k;
      this.y /= _k;
    }
    else println("Division by Zero!");
  }
  public void div(FloatVec _fv) {
    if (_fv.x != 0) this.x /= _fv.x;
    else println("Division by Zero!");
    if (_fv.y != 0) this.y /= _fv.y;
    else println("Division by Zero!");
  }
  public float mag() {
    return sqrt(pow(this.x,2) + pow(this.y,2));
  }
};
class FourierCircle {
  public float mag, phase, freq; // rad/frame
  FourierCircle(float _mag, float _phase, float _freq) {
    this.mag = _mag;
    this.phase = _phase;
    this.freq = _freq;
  }
  public void update() {
    this.phase += TWO_PI/60*this.freq * mouseX/width;
    if (this.phase >= TWO_PI) this.phase %= TWO_PI;
  }
  public void drawLine(FloatVec _pos, float _phase) {
    line(_pos.x, _pos.y, _pos.x + this.mag*cos(_phase + this.phase), _pos.y + this.mag*sin(_phase + this.phase));
  }
  public void drawCircle(FloatVec _pos) {
    circle(_pos.x, _pos.y, 2 * this.mag);
  }
};
// Used to compute and store FourtierTransform and wave

class FourierTransform {
  private Waveform waveform;
  private ArrayList<Complex> complexWave_Y = new ArrayList<Complex>();
  private FourierWave fourierWaveY = new FourierWave(new FloatVec(width/2,  height*3/4));
  public boolean doneFourier = false, drawFourier = false;
  private float span, freq = 0, drawStep = 0, threshold = 0.2f;
  
  FourierTransform(Waveform _waveform, float _span) {
    this.waveform = _waveform;
    this.span = _span;
    waveform.calcMin();
  }
  
  public void compute_Y(float _x, float _y) {
    push();
    translate(_x, _y);
    for (int i = 0; i < step/freqStep/60; i++) {
      if (freq < freqRange) {
        this.complexWave_Y.add(waveform.calcComplex_Y(freq, i == 0));
        freq += freqStep;
      } else {
        this.doneFourier = true;
      }
    }
    pop();
  }
  
  // fourier mag representation
  public void showComplexMag_Y(float _x, float _y) {
    push();
    translate(_x, _y);
    noFill();
    beginShape();
    stroke(255,0,255);
    for (int i = 0; i < this.complexWave_Y.size(); i++) {
      vertex(i * this.span/this.complexWave_Y.size() * freq/freqRange, -this.complexWave_Y.get(i).magnitude()); 
    }
    endShape();
    stroke(255,0,255, 255/4);
    if (this.drawFourier) line(0, -this.threshold, width/2, -this.threshold);
    pop();
  }
  
  // fourier phase representation
  public void showComplexPhase_Y(float _x, float _y) {
    push();
    translate(_x, _y);
    noFill();
    beginShape();
    stroke(0,255,0);
    for (int i = 0; i < this.complexWave_Y.size(); i++) {
      vertex(i * this.span/this.complexWave_Y.size() * freq/freqRange, -this.complexWave_Y.get(i).phase()*45/PI); 
    }
    endShape();
    pop();
  }
  
  // fourier complex components representation
  public void showComplexComponents_Y(float _x, float _y) {
    push();
    translate(_x, _y);
    noFill();
    beginShape();
    stroke(255,0,0);
    for (int i = 0; i < this.complexWave_Y.size(); i++) {
      vertex(i * this.span/this.complexWave_Y.size() * freq/freqRange, -this.complexWave_Y.get(i).a); 
    }
    endShape();
    beginShape();
    stroke(0,0,255);
    for (int i = 0; i < this.complexWave_Y.size(); i++) {
      vertex(i * this.span/this.complexWave_Y.size() * freq/freqRange, -this.complexWave_Y.get(i).b); 
    }
    endShape();
    pop();
  }
  
  // Final result
  private void createFourier_Y(String method) {
    if (!this.doneFourier) return;
    if (this.drawFourier) return;
    // this.threshold = 1;
    int index;
    
    Complex maxBefore = new Complex(0,0);
    Complex maxCurrent = new Complex(0,0);
    Complex maxAfter = new Complex(0,0);
   
    for (int i = 0; i < this.complexWave_Y.size(); i++) {
      
      // Method of max frequencies of neightbours
      if (method == "peak") {
        if (this.isMax_Y(i, this.complexWave_Y.size())) {
          
          // center i
          index = i;
          while (this.isMax_Y(index+1, this.complexWave_Y.size())) index++;
          i = (i+index)/2;
          
          maxCurrent = this.complexWave_Y.get(i);
          
          if (maxBefore.magnitude() == 0) {
            maxBefore = maxCurrent;
            continue;
          }
            
          // compare current max to max before
          if (maxCurrent.magnitude() > maxBefore.magnitude()) {
            
            // go to next max
            int tempI = index+1;
            while (tempI < this.complexWave_Y.size() && !this.isMax_Y(tempI, this.complexWave_Y.size())) tempI++;
            if (tempI >= this.complexWave_Y.size()) continue;
            
            // center tempI
            int indexTemp = tempI;
            while (tempI < this.complexWave_Y.size() && this.isMax_Y(indexTemp+1, this.complexWave_Y.size())) indexTemp++;
            if (tempI >= this.complexWave_Y.size()) continue;
            tempI = (tempI+indexTemp)/2;
            
            maxAfter = this.complexWave_Y.get(tempI);
            
            // println(maxBefore.magnitude(), maxCurrent.magnitude(), maxAfter.magnitude());
            
            // compare current max to max after
            if (maxCurrent.magnitude() > maxAfter.magnitude()) {
              this.fourierWaveY.addCircle(new FourierCircle(maxCurrent.magnitude()*2, maxCurrent.phase() - HALF_PI, i*freqStep));
              this.fourierWaveY.addCircle(new FourierCircle(maxCurrent.magnitude()*2, -maxCurrent.phase() - HALF_PI, -i*freqStep));
              
              println("Mag:", maxCurrent.magnitude());
              println("Phase:", maxCurrent.phase());
              println("Freq:", i*freqStep);
              
              stroke(255);
              line((float)i/this.complexWave_Y.size()*width/2, height/2, (float)i/this.complexWave_Y.size()*width/2, height);
            }
          }
          maxBefore = maxCurrent;
        }
      }
      
      else if (method == "any") {
        if (this.isMax_Y(i, this.complexWave_Y.size())) {
          
          // center i
          index = i;
          while (this.isMax_Y(index+1, this.complexWave_Y.size())) index++;
          i = (i+index)/2;
          
          maxCurrent = this.complexWave_Y.get(i);
      
          this.fourierWaveY.addCircle(new FourierCircle(maxCurrent.magnitude()*2, maxCurrent.phase() - HALF_PI, i*freqStep));
          this.fourierWaveY.addCircle(new FourierCircle(maxCurrent.magnitude()*2, -maxCurrent.phase() - HALF_PI, -i*freqStep));
          
          println("Mag:", maxCurrent.magnitude());
          println("Phase:", maxCurrent.phase());
          println("Freq:", i*freqStep);
          
          stroke(255);
          line((float)i/this.complexWave_Y.size()*width/2, height/2, (float)i/this.complexWave_Y.size()*width/2, height);
        }
      }
      
      else {
        println("error, invalid method used in FourierTransfrom.createFourier()");
        noLoop();
      }
    }
    run = false;
    this.drawFourier = true;
  }
  
   private boolean isMax_Y(int i, int upper) {
    int lowerIndex = i-1, upperIndex = i+1;
    if (lowerIndex < 0) return false;
    if (upperIndex >= upper) return false;
    
    if (this.complexWave_Y.get(lowerIndex).magnitude() <= this.complexWave_Y.get(i).magnitude() && this.complexWave_Y.get(i).magnitude() >= this.complexWave_Y.get(upperIndex).magnitude()) {
      if (this.complexWave_Y.get(i).magnitude() > this.threshold) return true;
      else return false;
    }
    else return false;
  }
  
  public void showFourierWave_Y() {
    if (this.doneFourier && !this.drawFourier) this.createFourier_Y("peak");
    else if (this.drawFourier) {     
      stroke(255);
      strokeWeight(1);
      this.fourierWaveY.showLine();
      
      if (drawStep >= width/2 / step) {
        noLoop();
        return;
      }
      // this.fourierWaveY.pos.x = width/2; //* unitsPerWindow;
      strokeWeight(2);
      this.fourierWaveY.show(true, true);
      this.fourierWaveY.offsetPoints_X(step * width/2 / (unitLength*unitsPerWindow) * mouseX/width);
      this.fourierWaveY.update();
      this.fourierWaveY.deleteExcess();
      drawStep += (float)mouseX/width; // += step*unitLength/60 * 2*mouseX/width;
      // frameRate(5);
    }
  }
  
  public void addPoint_Y(Complex _c) {
    this.complexWave_Y.add(_c);
  }
};
// Used for showing and updating FourierWave

class FourierWave {
  public FloatVec pos;
  private ArrayList<FourierCircle> circles = new ArrayList<FourierCircle>();
  public ArrayList<FloatVec> points = new ArrayList<FloatVec>();
  FourierWave(FloatVec _pos) {
    this.pos = _pos;
  }
  public void addCircle(FourierCircle circle) {
    circles.add(circle);
  }
  public void show(boolean _line, boolean _circle) {    
    FloatVec prevOffset = new FloatVec(), offset = new FloatVec();
    prevOffset.copy(pos);
    float prevPhase = 0;
    FourierCircle c;
    for (int i = 0; i < circles.size(); i++) {  
      c = circles.get(i);
      offset.set(prevOffset.x + c.mag * cos(c.phase + prevPhase), prevOffset.y + c.mag * sin(c.phase + prevPhase));
      if (_circle) {
        stroke(255, 255/4);
        c.drawCircle(prevOffset);   
      }
      if (_line) {
        stroke(255);
        c.drawLine(prevOffset, prevPhase);
      }
      prevOffset.copy(offset);
    }
  }
  public void update() {
    FloatVec prevOffset = new FloatVec(), offset = new FloatVec();
    prevOffset.copy(pos);
    FourierCircle c;
    for (int i = 0; i < circles.size(); i++) {  
      c = circles.get(i);
      offset.set(prevOffset.x + c.mag * cos(c.phase), prevOffset.y + c.mag * sin(c.phase));
      c.update();
      prevOffset.copy(offset);
    }
    points.add(offset);
  }
  public void showPoints() {
    for (int i = 0; i < points.size(); i++) {
      point(points.get(i).x, points.get(i).y);
    }
  }
  public void offsetPoints_X(float _x) {
    //if (points.size() > 0) points.get(points.size()-1).x = _x;
    for (int i = 0; i < points.size(); i++) {
      points.get(i).x += _x;
    }
  }
  public void showLine() {
    beginShape();
    for (int i = 0; i < points.size(); i++) {
      vertex(points.get(i).x, points.get(i).y);
    }
    endShape();
  }
  public void deleteExcess() {
    for (int i = 0; i < points.size(); i++) {
      if (points.get(i).x > width) points.remove(i);
    }
  }
}
// Used for original/input wave

class Waveform {
  public ArrayList<FloatVec> floatWave = new ArrayList<FloatVec>();
  private float span, min;
  
  // floatWaveform
  Waveform() {}
  
  // floatWaveform (cosine)
  Waveform(float _span, float _mag, float _freq, float _phase) {
    this.span = _span;
    
    // Sine floatWave
    for (float i = 0; i < this.span; i += 1/step) {
      this.floatWave.add(new FloatVec(i, _mag*cos(TWO_PI * _freq * i / unitLength + _phase)));
    }
  }
  
  // floatWaveform (square)
  Waveform(float _span, float _mag) {
    this.span = _span;
    
    // Square floatWave
    for (float i = 0; i < this.span; i += 1/step) {
      if (i%unitLength < unitLength/2) this.floatWave.add(new FloatVec(i, _mag));
      else this.floatWave.add(new FloatVec(i, -_mag));
    }
  }
  
  // floatWaveform (input)
  Waveform(ArrayList<FloatVec> _waveform, float _span) {
    this.span = _span;
    
    for (int i = 0; i < _waveform.size(); i++) {
      this.floatWave.add(new FloatVec(_waveform.get(i).x, _waveform.get(i).y));
    }
  }
  
  // wave representation
  public void showFloatWave(float _x, float _y) {
    push();
    translate(_x, _y);
    noFill();
    beginShape();
    for (int i = 0; i < this.floatWave.size(); i++) {
      vertex(this.floatWave.get(i).x, -this.floatWave.get(i).y); 
    }
    endShape();
    pop();
  }
  
  //public void addPoint(FloatVec _fv) {
  //  this.floatWave.add(_fv);
  //}
  
  // Used for combining cosine waves
  public void addFloatWave(Waveform _floatWaveForm) {
    for (int i = 0; i < this.floatWave.size(); i++) {
      this.floatWave.get(i).y += _floatWaveForm.floatWave.get(i).y;
    }
  }
  
  private void calcMin() {
    float min = this.floatWave.get(0).y;
    for (int i = 1; i < this.floatWave.size(); i++) {
      if (this.floatWave.get(i).y < min) min = this.floatWave.get(i).y;
    }
    this.min = min;
  }
  
  // Revolution
  public Complex calcComplex_Y(float _freq, boolean _draw) {
    // if (this.doneFourier) return;
    // boolean fullRevolution = false;
    float mag, phase = 0;
    Complex avg = new Complex();
    noFill();
    beginShape();
    stroke(255);
    for (int i = 0; i < this.floatWave.size(); i++) {
      mag = (floatWave.get(i).y - this.min)*1/2;
      if (_draw) vertex(mag*cos(phase), -mag*sin(phase));
      // if (fullRevolution) 
      avg.add(mag*cos(phase), mag*sin(phase));
      phase -= TWO_PI*_freq/unitLength/step;
      // if (phase <= -TWO_PI) fullRevolution = true;
    }
    
    endShape();
    stroke(255,0,0);
    fill(255,0,0);
    avg.div(this.floatWave.size());
    if (_draw) circle(avg.a, -avg.b, 5);
    // this.complexWave.add(avg);
    return avg;
  }
};


  public void settings() { size(1200, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Fourier" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
